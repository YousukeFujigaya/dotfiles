#!/usr/bin/env bash
set -e
# shellcheck source=./scripts/common
source "$(dirname "$0")/common"
source "$(dirname "$0")/utils"

DOTFILES_HOME="$GHQ_ROOT_PATH"/github.com/"$GITHUB_USER_NAME"/dotfiles
STOW_PACKAGES_PATH="$DOTFILES_HOME"/packages

###########################################################
# Options
###########################################################
unlink_packages=()
for i in "$@"; do
    case "$i" in
    -u | --unlink)
        shift
        while [[ "$1" != -* && ! -z "$1" ]]; do
            if [[ "$1" != "-u" && "$1" != "--unlink" ]]; then
                unlink_packages+=("$1")
            fi
            shift
        done
        ;;
    -uall | --unlink-all)
        unlink_all=1
        shift
        ;;
    *) ;;
    esac
done

###########################################################
# Clean broken symlinks
###########################################################
clean_broken_symlinks() {
    log 'Cleaning broken symlinks...'

    # Find broken symlinks that point to dotfiles packages
    broken_links=()

    # Search in home directory (excluding .config to avoid duplicates)
    while IFS= read -r -d '' link; do
        if [[ -L "$link" ]] && [[ ! -e "$link" ]]; then
            target=$(readlink "$link")
            # Check if the symlink points to our dotfiles packages or scripts
            if [[ "$target" == *"dotfiles/packages/"* ]] || [[ "$target" == *"dotfiles/scripts/"* ]]; then
                broken_links+=("$link")
            fi
        fi
    done < <(find "$HOME" -maxdepth 1 -type l -print0 2>/dev/null)

    # Search in ~/.config
    while IFS= read -r -d '' link; do
        if [[ -L "$link" ]] && [[ ! -e "$link" ]]; then
            target=$(readlink "$link")
            # Check if the symlink points to our dotfiles packages
            if [[ "$target" == *"dotfiles/packages/"* ]]; then
                broken_links+=("$link")
            fi
        fi
    done < <(find "$HOME/.config" -type l -print0 2>/dev/null)

    # Search in ~/.local/bin for broken script links
    if [[ -d "$HOME/.local/bin" ]]; then
        while IFS= read -r -d '' link; do
            if [[ -L "$link" ]] && [[ ! -e "$link" ]]; then
                target=$(readlink "$link")
                # Check if the symlink points to our dotfiles scripts
                if [[ "$target" == *"dotfiles/scripts/"* ]]; then
                    broken_links+=("$link")
                fi
            fi
        done < <(find "$HOME/.local/bin" -type l -print0 2>/dev/null)
    fi

    if [ ${#broken_links[@]} -gt 0 ]; then
        log "Found ${#broken_links[@]} broken symlinks, removing them..."
        for link in "${broken_links[@]}"; do
            log "Removing broken symlink: $link"
            rm "$link"
        done
        log 'Broken symlinks removed successfully.'
    fi
}

###########################################################
# Unlink
###########################################################
if [ ${#unlink_packages[@]} -gt 0 ]; then
    for package in "${unlink_packages[@]}"; do
        log "Unlinking packages: $package"
        stow -vD -d "$STOW_PACKAGES_PATH" -t ~ "$package"
    done
    exit
fi

if [ "$unlink_all" = 1 ]; then
    submodules=$(awk '/path/ {print $3}' "$DOTFILES_HOME/.gitmodules" | sed 's|.*/||')
    full_paths="$(fd --hidden --no-ignore -t f -H -I -E "$submodules" -E "zsh" . "$STOW_PACKAGES_PATH")"

    # Extract unique package names from paths
    unlink_packages=()
    while IFS= read -r package_name; do
        [[ " ${unlink_packages[*]} " =~ " ${package_name} " ]] || unlink_packages+=("$package_name")
    done < <(echo "$full_paths" | sed -n 's|.*/packages/\([^/]*\)/.*|\1|p' | sort -u)

    log 'Unlinking all packages...'
    for package in "${unlink_packages[@]}"; do
        stow -vD -d "$STOW_PACKAGES_PATH" -t "$HOME" "$package"
    done
    # -------------------------------------------------------------------------
    log 'Unlinking scripts...'

    unlink_script_paths=($(find "${DOTFILES_HOME}/scripts" -type f -exec basename {} \;))
    for script_name in "${unlink_script_paths[@]}"; do
        rm "$HOME/.local/bin/$script_name"
    done

    exit
fi

# Clean broken symlinks before linking
clean_broken_symlinks

##########################################################
# link
##########################################################
### mkdir
make_dir=(
    "$XDG_CONFIG_HOME"
    "$XDG_STATE_HOME"
    "$XDG_CACHE_HOME"
    "$XDG_CONFIG_HOME/zsh"
)
for dir in "${make_dir[@]}"; do
    ensure_dir "$dir"
done

ensure_dir "$HOME/.ssh"
chmod 700 "$HOME/.ssh"

# ensure_dir "$HOME/.gnupg"
# chmod 700 "$HOME/.gnupg"

### Stow link ###
log 'Linking packages...'
# Use array to handle package names with spaces safely
packages=()
while IFS= read -r -d '' package; do
    packages+=("$(basename "$package")")
done < <(find "$STOW_PACKAGES_PATH" -mindepth 1 -maxdepth 1 -type d -print0)

if [ ${#packages[@]} -gt 0 ]; then
    stow -vd "$STOW_PACKAGES_PATH" -t "$HOME" "${packages[@]}"
fi

# -------------------------------------------------------------------------
log 'Linking scripts...'
ensure_dir "$HOME/.local/bin"
# Link individual scripts safely
for script in "$DOTFILES_HOME/scripts/"*; do
    if [ -f "$script" ]; then
        script_name="$(basename "$script")"
        safe_symlink "$script" "$HOME/.local/bin/$script_name"
    fi
done

# -------------------------------------------------------------------------
